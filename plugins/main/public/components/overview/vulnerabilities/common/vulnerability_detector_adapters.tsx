import {
  AUTHORIZED_AGENTS,
  VULNERABILITY_IMPLICIT_CLUSTER_MODE_FILTER,
  WAZUH_ALERTS_PATTERN,
} from '../../../../../common/constants';
import { AppState } from '../../../../react-services';
import { FilterHandler } from '../../../../utils/filter-handler';
import { Filter } from '../../../../../../../src/plugins/data/public';
import { FilterManager } from '../../../../../../../src/plugins/data/public';
import { FilterStateStore } from '../../../../../../../src/plugins/data/common';

const SESSION_STORAGE_FILTERS_NAME = 'wazuh_persistent_searchbar_filters';
const SESSION_STORAGE_PREV_FILTER_NAME = 'wazuh_persistent_current_filter';

/**
 * When the component is unmounted, the original filters that arrived
 * when the component was mounted are added.
 * Both when the component is mounted and unmounted, the index pattern is
 * updated so that the pin action adds the agent with the correct index pattern.
 */
export const vulnerabilityIndexFiltersAdapter = (
  filterManager: FilterManager,
  defaultIndexPatternID: string,
) => {
  const filterHandler = new FilterHandler(AppState.getCurrentPattern());
  const initialFilters: Filter[] = [];
  const storagePreviousFilters = sessionStorage.getItem(
    SESSION_STORAGE_FILTERS_NAME,
  );
  if (storagePreviousFilters) {
    const previousFilters = JSON.parse(storagePreviousFilters);
    const previousFiltersWithoutImplicitFilters = previousFilters.filter(
      (filter: Filter) => !filter?.$state?.isImplicit,
    );
    previousFiltersWithoutImplicitFilters.forEach((filter: Filter) => {
      initialFilters.push(filter);
    });
  }

  /**
      Add vulnerability module implicit filters
    */
  const isCluster = AppState.getClusterInfo().status == 'enabled';
  const managerFilter = filterHandler.managerQuery(
    isCluster
      ? AppState.getClusterInfo().cluster
      : AppState.getClusterInfo().manager,
    true,
    VULNERABILITY_IMPLICIT_CLUSTER_MODE_FILTER[
      AppState.getClusterInfo().status
    ],
  );

  // rule.groups is added so that the events tab can use it
  const ruleGroupsFilter = filterHandler.ruleGroupQuery(
    'vulnerability-detector',
  );
  initialFilters.unshift(ruleGroupsFilter);
  initialFilters.unshift(managerFilter);
  const vulnerabilitiesFilters = initialFilters.map((filter: Filter) => {
    return {
      ...filter,
      meta: {
        ...filter.meta,
        index: defaultIndexPatternID,
      },
    };
  });
  sessionStorage.setItem(
    SESSION_STORAGE_FILTERS_NAME,
    JSON.stringify(initialFilters),
  );
  /* The rule.groups filter is removed. It is not applicable to the case of the vulnerabilities module since it has its own index */
  const vulnerabilitiesFiltersWithoutRuleGroup = vulnerabilitiesFilters.filter(
    (filter: Filter) => filter.meta.key !== 'rule.groups',
  );
  const implicitPinnedAgent = getImplicitPinnedAgent(
    initialFilters,
    defaultIndexPatternID,
  );
  if (implicitPinnedAgent) {
    const filtersWithoutNormalAgents =
      vulnerabilitiesFiltersWithoutRuleGroup.filter(x => {
        return x.meta.key !== 'agent.id';
      });
    filtersWithoutNormalAgents.push(implicitPinnedAgent);
    filterManager.setFilters(filtersWithoutNormalAgents);
  } else {
    filterManager.setFilters(vulnerabilitiesFiltersWithoutRuleGroup);
  }
};

export const restorePrevIndexFiltersAdapter = (
  previousFilters: Filter[],
  toIndexPattern: string | null,
  filterManager: FilterManager,
  defaultIndexPatternID: string,
) => {
  const filterHandler = new FilterHandler(AppState.getCurrentPattern());
  const isCluster = AppState.getClusterInfo().status == 'enabled';
  const cleanedFilters = cleanFilters(
    previousFilters,
    defaultIndexPatternID,
  ).filter(
    (filter: Filter) =>
      filter?.meta?.key !==
      VULNERABILITY_IMPLICIT_CLUSTER_MODE_FILTER[
        AppState.getClusterInfo().status
      ],
  );
  /* Restore original manager implicit filter */
  const managerFilter = filterHandler.managerQuery(
    isCluster
      ? AppState.getClusterInfo().cluster
      : AppState.getClusterInfo().manager,
    isCluster,
  );
  cleanedFilters.unshift(managerFilter);
  const implicitPinnedAgent = getImplicitPinnedAgent(
    previousFilters,
    toIndexPattern ?? WAZUH_ALERTS_PATTERN,
  );
  if (implicitPinnedAgent) {
    const cleanedFiltersWithoutNormalAgents = cleanedFilters.filter(x => {
      return x.meta.key !== 'agent.id';
    });
    cleanedFiltersWithoutNormalAgents.push(implicitPinnedAgent);
    filterManager.setFilters(cleanedFiltersWithoutNormalAgents);
  } else {
    filterManager.setFilters(cleanedFilters);
  }
};

export const onUpdateAdapter = (
  filters: Filter[],
  filterManager: FilterManager,
  onFiltersUpdated?: (filters: Filter[]) => void,
) => {
  const prevStoragePattern = sessionStorage.getItem(
    SESSION_STORAGE_PREV_FILTER_NAME,
  );
  const storagePreviousFilters = sessionStorage.getItem(
    SESSION_STORAGE_FILTERS_NAME,
  );
  /**
   * If there are persisted filters, it is necessary to add them when
   * updating the filters in the filterManager
   */
  const cleanedFilters = cleanFilters(
    filters,
    prevStoragePattern ?? WAZUH_ALERTS_PATTERN,
  );
  if (storagePreviousFilters) {
    const previousFilters = JSON.parse(storagePreviousFilters);
    const previousImplicitFilters = previousFilters.filter(
      (filter: Filter) => filter?.$state?.isImplicit,
    );
    const cleanedPreviousImplicitFilters = cleanFilters(
      previousImplicitFilters,
      prevStoragePattern ?? WAZUH_ALERTS_PATTERN,
    );
    /* Normal filters added to storagePreviousFilters are added to keep them between dashboard and inventory tab */
    const newFilters = filters.filter(
      (filter: Filter) => !filter?.$state?.isImplicit,
    );

    sessionStorage.setItem(
      SESSION_STORAGE_FILTERS_NAME,
      JSON.stringify([...previousImplicitFilters, ...newFilters]),
    );

    filterManager.setFilters([
      ...cleanedPreviousImplicitFilters,
      ...cleanedFilters,
    ]);
    onFiltersUpdated &&
      onFiltersUpdated([...cleanedPreviousImplicitFilters, ...cleanedFilters]);
  } else {
    filterManager.setFilters(cleanedFilters);
    onFiltersUpdated && onFiltersUpdated(cleanedFilters);
  }
};

/**
 * Verify if a pinned agent exists, identifying it by its meta.isImplicit attribute or by the agentId query param URL.
 * We also compare the agent.id filter with the agentId query param because the OSD filter definition does not include the "isImplicit" attribute that Wazuh adds.
 * There may be cases where the "isImplicit" attribute is lost, since any action regarding filters that is done with the
 * filterManager ( addFilters, setFilters, setGlobalFilters, setAppFilters)
 * does a mapAndFlattenFilters mapping to the filters that removes any attributes that are not part of the filter definition.
 * */
const getImplicitPinnedAgent = (
  filters: Filter[],
  toIndexPattern: string,
): Filter | undefined => {
  const pinnedAgentByFilterManager = filters.find(
    (filter: Filter) =>
      filter?.meta?.key === 'agent.id' && !!filter?.$state?.isImplicit,
  );
  const url = window.location.href;
  const regex = new RegExp('agentId=' + '[^&]*');
  const match = url.match(regex);
  const isPinnedAgentByUrl = match && match[0];
  if (pinnedAgentByFilterManager && isPinnedAgentByUrl) {
    return {
      ...pinnedAgentByFilterManager,
      meta: {
        ...pinnedAgentByFilterManager.meta,
        index: toIndexPattern,
      },
      $state: { store: FilterStateStore.APP_STATE, isImplicit: true },
    };
  }

  if (isPinnedAgentByUrl) {
    const agentId = match[0].split('=')[1];
    return {
      meta: {
        alias: null,
        disabled: false,
        key: 'agent.id',
        negate: false,
        params: { query: agentId },
        type: 'phrase',
        index: toIndexPattern,
      },
      query: {
        match: {
          'agent.id': {
            query: agentId,
            type: 'phrase',
          },
        },
      },
      $state: { store: 'appState', isImplicit: true },
    };
  }
  return undefined;
};

/**
 * Return cleaned filters.
 * Clean the known issue with the auto loaded agent.id filters from the searchbar
 * and filters those filters that are not related to the default index pattern.
 * This cleanup adjusts the index pattern of a pinned agent, if applicable.
 * @param previousFilters
 * @returns
 */
const cleanFilters = (
  previousFilters: Filter[],
  indexPatternToClean: string,
) => {
  const mappedFilters = previousFilters.filter(
    (filter: Filter) =>
      filter?.meta?.controlledBy !== AUTHORIZED_AGENTS && // remove auto loaded agent.id filters
      filter?.meta?.index !== indexPatternToClean,
  );
  return mappedFilters;
};
